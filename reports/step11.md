# Step 11

## 实验内容

本次实验需要实现指针类型，并且进行左值分析和类型检查

词法分析相对简单，修改assignment的前件从identifier到unary

在类型的表示上，使用了整数来表示`int`和`int`的指针，0表示`int`，1表示`int*`

在IR生成阶段进行类型检查，例如将加法expression生成IR时检查类型是否都为int。

进行左值分析时，对AST节点进行递归分析，满足左值规范的认为是左值。

## 思考题

### 1. 为什么类型检查要放到名称解析之后？

因为类型检查需要有完整的AST，有了AST后，每个AST节点的类型可以递归地得出，因此需要先进行名称解析构建AST。

### 2. MiniDecaf 中一个值只能有一种类型，但在很多语言中并非如此，请举出一个反例。

对于这个问题的理解取决于怎么理解“值”，如果理解为字面量，如字面整数`0x123`，那么`0x123`这样的字面量都是有默认类型的，在赋值语句中会进行隐式的类型转换。例如x64机器上的C++将`0.1`这样的字面量默认认为是double类型，但是也可以用在float变量的赋值语句中。

相似的，对于支持类继承和多态的C++，基类`Base`，派生类`Derived`，可以有`Base* pA = new Derived();`， 也可以有`Derived* pB = new Derived();`，可以认为`new Derived()`既可以是基类指针，也可以是派生类指针。（当然，可以认为通过隐式类型转换实现）

那么，可以看出实际上面说的话中，符号表里的每个变量还是都是有固定的一种类型的，只是因为允许隐式类型转换，这种类型系统习惯上被称为静态弱类型。

如果将这个“值”理解为动态语言中的表达式，那么使用动态类型的语言的表达式的类型是可以变化的，例如Python，一个变量可以先代表整数，后面再被修改为代表一个字符串。

### 3. 在本次实验中我们禁止进行指针的比大小运算。请问如果要实现指针大小比较需要注意什么问题？可以和原来整数比较的方法一样吗？

首先，只有指向连续的内存中的两个指针的大小比较才有意义，如果是分别指向不连续的内存的指针，那么比较无意义。

虽然指针在比较时可以视为整数，但是一般编译器会要求相同类型的指针才可以比较。